# L08: Cache Coherency

Cache Coherency means

- the values in all caches are consistent; and

- to some extent, the system behaves as if all CPUs are using shared memory.

Initially in main memory: `x = 7`.

1. CPU1 reads `x`, puts the value in its cache.
2. CPU3 reads `x`, puts the value in its cache.
3. CPU3 modifies `x := 42` (writes to memory as well)
4. CPU1 reads `x := 7` from its cache (‚ùå)
5. CPU2 reads `x`. Which value does it get?

To know something has changed

- check before use

- get notified

## Snoopy coherence mechanism

Caches are spying on each other. It is workable because they have a shared bus
(see how a system bus works <https://en.wikipedia.org/wiki/System_bus>). The
*write-invalidate protocols* and *write-update protocols* make use of this
mechanism. Because write-invalidate protocol is the most common protocol, so we
will only talk about that here.

### Write-Through Protocol

The protocol for implementing such caches looks like this. There are two
possible states, **valid** and **invalid**, for each cached memory location.
Events are either from a processor (**Pr**) or the **Bus**. Actions will be
either a **Rd** (read) or **Wr** (write). We then implement the following state
machine.

|State   | Observed | Generated | Next State|
|--------|----------|-----------|-----------|
|Valid   | PrRd     |           | Valid     |
|Valid   | PrWr     | BusWr     | Valid     |
|Valid   | BusWr    |           | Invalid   |
|Invalid | PrWr     | BusWr     | Valid     |
|Invalid | PrRd     | BusRd     | Valid     |

Therefore, for the above example, CPU1 will snoop and mark data as invalid in
the step 3.

### Write-Back Protocols

This is used to merge multiple writes into a single flush. At minimum, we need
support in hardware for a "dirty" bit, which indicates the our data has been
changed but not yet been written to memory.

#### MSI

**M**odified, **S**hared, and **I**nvalid

#### MESI

 **M**odified, ***E***_xclusive_, **S**hared, and **I**nvalid

#### MESIF

 **M**odified, **E**xclusive, **S**hared, **I**nvalid, and ***F***_orward_

## False Sharing

False sharing is something that happens when our program has two unrelated data
elements that are mapped to the same cache line/location. It seems the cache is
shared but in fact it is not. (See `L08/false_sharing`)
