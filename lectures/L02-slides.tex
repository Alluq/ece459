\input{configuration}


\title{Lecture 2 --- Rust Basics }

\author{Jeff Zarnett \\ \small \texttt{jzarnett@uwaterloo.ca}}
\institute{Department of Electrical and Computer Engineering \\
  University of Waterloo}
\date{\today}


\begin{document}

\begin{frame}
  \titlepage

 \end{frame}
 
 
\begin{frame}
\frametitle{Rust}

We won't tell you to just go learn Rust on your own...

\begin{center}
	\includegraphics[width=0.5\textwidth]{images/rustacean.png}
\end{center}

Focus: important features: why \& how they support the goal of performance.

\end{frame}


\begin{frame}
\frametitle{Learning to Swim}

Reading or watching about a programming language isn't super effective.

There's no substitute for writing code! 

Suggestion: do practice exercises to become familiar with the language.

\end{frame}


\begin{frame}
\frametitle{Goal-Setting}

\begin{center}
	\includegraphics[width=0.4\textwidth]{images/batteries.jpg}
\end{center}

Some things aren't here. We're not covering the very basics of Rust.

The official docs are good and you will get used to the syntax as we use it.

\end{frame}


\begin{frame}[fragile]
\frametitle{Semicolon}

Previously: C/\CPP/Java, where all statements end with semicolons.

In Rust that is not so: semicolons separate expressions. 

The last expression in a function is its return value. 

You can use \texttt{return} to get C-like behaviour, but you don't have to.
\begin{lstlisting}[language=Rust]
  fn return_a_number() -> u32 {
    let x = 42;
    x+17
  }

  fn also_return() -> u32 {
    let x = 42;
    return x+17;
  }
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
\frametitle{Change is Painful}

Variables in Rust are, by default, immutable.

\begin{lstlisting}[language=Rust]
  fn main() {
    let x = 42; // NB: Rust infers type "i32" for x.
    x = 17;     // compile-time error!
  }
\end{lstlisting}

Immutability is good for performance.

The compiler can reason about the possibility of race conditions.

No writes? No race condition!

\end{frame}


\begin{frame}[fragile]
\frametitle{This has happened...}

If you don't believe me, here's an example in C of where this could go wrong:
\begin{lstlisting}[language=C]
if ( my_pointer != NULL ) {
    int size = my_pointer->length; // Segmentation fault occurs!
    /* ... */
}
\end{lstlisting}

What happened? We checked if \texttt{my\_pointer} was null?

\end{frame}


\begin{frame}
\frametitle{Diamonds are Forever}

Immutability in Rust is forever (ish).

The compiler will not let you make changes to something via trickery.

\begin{center}
	\includegraphics[width=0.5\textwidth]{images/sabrina.jpeg}
\end{center}


Rust grudgingly permits such dark magicks, but you you have to brand your code with the \texttt{unsafe} keyword and are subject to undefined behaviour.

\end{frame}


\begin{frame}
\frametitle{Change is Necessary}

If you want for a variable's value to be changeable you certainly can, but you have to explicitly declare it as \textit{mutable}

Add \texttt{mut} to the definition, like \texttt{let mut x = 42;}

Generally, minimize the number of times you use this.

Rust forces you to make mutability explicit \& has the compiler check your work.

\end{frame}


\begin{frame}
\frametitle{The Tao is Eternal}

There are constants, which are different from global variables. 

Constants are both immutable and immortal.

\texttt{const SPEED\_OF\_LIGHT\_M\_S: u32 = 299\_792\_458;}.

They don't really exist at runtime and have no address.

Rust also has global variables, defined using \texttt{static}.

\end{frame}


\begin{frame}[fragile]
\frametitle{Shadowing}

\begin{center}
	\includegraphics[width=0.5\textwidth]{images/darklink.jpg}
\end{center}
\alert{Shadowing} is intended to address the problem of ``What do I name this?''

An example from the docs:

\begin{lstlisting}[language=Rust]
let mut guess = String::new();

io::stdin().read_line(&mut guess)
     .expect("Failed to read line");

let guess: u32 = guess.trim().parse()
     .expect("Please type a number!");
\end{lstlisting}

\end{frame}


\begin{frame}
\frametitle{Memory Management}

In languages like C, memory management is manual: you allocate and deallocate memory using explicit calls.

In other languages like Java, it's partly manual---you explicitly allocate memory but deallocation takes place through garbage collection. 

\CPP~supports memory management via RAII, and Rust does the same.

Rust does so at compile-time with guarantees, through ownership, which we'll discuss below.
\end{frame}


\begin{frame}
\frametitle{Garbage Collection}

You might be thinking: what's wrong with garbage collection?

The real answer is the magic word: performance!

Runtime and actual costs of collecting the garbage.

\end{frame}




\end{document}

