\documentclass[letterpaper,10pt]{article}

\usepackage{titling}
\usepackage{listings}
\usepackage{url}
\usepackage{setspace}
\usepackage{subfig}
\usepackage{sectsty}
\usepackage{pdfpages}
\usepackage{colortbl}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{relsize}
\usepackage{amsmath}
\usepackage{wasysym}
\usepackage{fancyvrb}
\usepackage{amsmath,amssymb,amsthm,graphicx,xspace}
\usepackage[titlenotnumbered,noend,noline]{algorithm2e}
\usepackage[compact]{titlesec}
\usepackage{XCharter}
\usepackage[T1]{fontenc}
\usepackage{tikz}
\usetikzlibrary{arrows,automata,shapes,trees,matrix,chains,scopes,positioning,calc}
\tikzstyle{block} = [rectangle, draw, fill=blue!20, 
    text width=2.5em, text centered, rounded corners, minimum height=2em]
\tikzstyle{bw} = [rectangle, draw, fill=blue!20, 
    text width=4em, text centered, rounded corners, minimum height=2em]

\definecolor{namerow}{cmyk}{.40,.40,.40,.40}
\definecolor{namecol}{cmyk}{.40,.40,.40,.40}

\let\LaTeXtitle\title
\renewcommand{\title}[1]{\LaTeXtitle{\textsf{#1}}}


\newcommand{\handout}[5]{
  \noindent
  \begin{center}
  \framebox{
    \vbox{
      \hbox to 5.78in { {\bf ECE459: Programming for Performance } \hfill #2 }
      \vspace{4mm}
      \hbox to 5.78in { {\Large \hfill #4  \hfill} }
      \vspace{2mm}
      \hbox to 5.78in { {\em #3 \hfill} }
    }
  }
  \end{center}
  \vspace*{4mm}
}

\newcommand{\lecture}[3]{\handout{#1}{#2}{#3}{Lecture #1}}
\newcommand{\tuple}[1]{\ensuremath{\left\langle #1 \right\rangle}\xspace}

\addtolength{\oddsidemargin}{-1.000in}
\addtolength{\evensidemargin}{-0.500in}
\addtolength{\textwidth}{2.0in}
\addtolength{\topmargin}{-1.000in}
\addtolength{\textheight}{1.75in}
\addtolength{\parskip}{\baselineskip}
\setlength{\parindent}{0in}
\renewcommand{\baselinestretch}{1.5}
\newcommand{\term}{Winter 2017}

\singlespace

\title{\bf ECE 459: Programming for Performance\\Assignment 2}
\author{Patrick Lam \& Jeff Zarnett}
\date{\today ~ (Due: February 27, 2017)}

\lstset{basicstyle=\scriptsize, frame=single}

\begin{document}

\maketitle
% http://gurmeet.net/2008/09/20/latex-tips-n-tricks-for-conference-papers/
\newcommand{\squishlist}{
 \begin{list}{$\bullet$}
  { \setlength{\itemsep}{0pt}
     \setlength{\parsep}{3pt}
     \setlength{\topsep}{3pt}
     \setlength{\partopsep}{0pt}
     \setlength{\leftmargin}{1.5em}
     \setlength{\labelwidth}{1em}
     \setlength{\labelsep}{0.5em} } }
\newcommand{\squishend}{
  \end{list}  }

\noindent
Important Notes:

\squishlist
  \item {\bf Make sure you run your program on {\tt ece459-1.uwaterloo.ca}.}
  \item {\bf Use the command ``{\tt OMP\_NUM\_THREADS=4;export OMP\_NUM\_THREADS}'' to set 4 threads.}
  \item {\bf Run ``{\tt make report}'' and push your fork of the {\tt a2} directory.}
  \item {\bf Make sure you don't change the behaviour of the program.}
\squishend

\noindent
Fork the provided git repository at {\tt git@ecegit.uwaterloo.ca:ece459/1181/a2}:
\begin{center}
{\tt ssh git@ecegit.uwaterloo.ca fork ece459/1181/a2 ece459/1181/USERNAME/a2}
\end{center}
\noindent and then clone the provided files.

Grading will be done by running {\tt make}, running your programs,
looking at the source code and reading the report.

\section{Automatic Parallelization (15 marks)}
Ray tracing is, in principle, easy to automatically parallelize. You do
a separate computation for each point. In this part, you will convince a
parallelizing compiler (I recommend Oracle's Solaris Studio) to parallelize
a simple raytracing computation.

For this question, you will work with {\tt raytrace\_simple.c} and {\tt
  raytrace\_auto.c} in the {\tt q1} directory.  I've bumped up the
height of the image to 60000 pixels so that the compiler will find it
profitable to parallelize. Benchmark the sequential ({\tt raytrace})
and optimized sequential ({\tt raytrace\_opt}) versions. Note that the
compiler does manage to optimize the computation of the sequential
raytrace quite a bit. Report the speedup due to the compiler and
speculate about why that is the case. Compare all subsequent numbers
to the optimized version.

Your first programming task is to modify your program so you can take
advantage of automatic parallelization. Figure out why it won't
parallelize as is, and make any changes necessary. Preserve behaviour
and make all your changes to {\tt raytrace\_auto.c}.

I put Solaris Studio 12.3 on {\tt ece459-1}. The provided {\tt
  Makefile} calls that compiler with the relevant flags. Your compiler
output should look something like the following (the line numbers
don't have to match, but you {\bf must} parallelize the critical loop):

\newpage
\begin{lstlisting}
Compiling Part 1 Automatic Parallelization
/opt/oracle/solarisstudio12.3/bin/cc  -fast -xautopar -xloopinfo -xreduction -xbuiltin -xO4 \
    src/raytrace_auto.c -o bin/raytrace_auto
"raytrace_auto.c", line 217: PARALLELIZED
"raytrace_auto.c", line 218: not parallelized, not profitable
"raytrace_auto.c", line 233: not parallelized, loop has multiple exits
"raytrace_auto.c", line 241: not parallelized, not a recognized for loop
"raytrace_auto.c", line 264: not parallelized, not a recognized for loop
\end{lstlisting}

Clearly and concisely explain your changes. Explain why the code would
not parallelize initially, why your changes are correct but bad for
maintainability, and why they preserve the behaviour of the sequential
version. Run your benchmark again and calculate your
speedup. Speculate about why you got your speedup.

\squishlist
  \item {\bf Minimum expected speedup:} 1.1
  \item {\bf (my) initial solution speedup:} 1.1
\squishend

\paragraph{Totally unrelated hints.} Consider this page:
\begin{center}
  \scriptsize \url{http://stackoverflow.com/questions/321143/good-programming-practices-for-macro-definitions-define-in-c}
\end{center}
Also, let's say that you want a macro to return a struct of type {\tt struct foo} with
two fields. You can create such a struct on-the-fly like so: \verb!(struct foo){1,2}!.

\section{Using OpenMP Tasks (30 marks)}

We saw briefly how OpenMP tasks allow us to easily express some parallelism.
In this part, we apply OpenMP tasks to the $n$-queens
problem\footnote{\url{http://jsomers.com/nqueen_demo/nqueens.html}}.
Benchmark the sequential version with a number that executes in approximately
15 seconds under {\tt -O2} (14 on {\tt ece459-1}).

\noindent {\bf Notes:} Use {\tt er\_src} to get more detail about what the Oracle
Solaris Studio compiler did.  You may change the
Makefile's compilation flags if needed. Report speedups over the
compiler-optimized sequential version.  You can use any compiler, but
say which one you used. OpenMP tips:
\begin{center}
  \url{www.viva64.com/en/a/0054/}
\end{center}

Modify the code to use OpenMP tasks. Benchmark your modified program
and calculate the speedup. Clearly and concisely explain why your
changes improved performance. Write a couple of sentences explaining how
you could further improve performance.

\vspace*{1em}
\noindent {\bf Hints:} 1) Be sure to get the right variable scoping, or
you'll get race conditions. 2) Just adding the task annotation is going
to make your code way slower. 3) You will have to implement a cutoff to
get speedup. See, for instance, the Google results for ``openmp
fibonacci tasks''. 4) My solution includes 4 annotations and some
cutting-and-pasting of code.

\squishlist
  \item {\bf Minimum expected speedup:} 1.5
  \item {\bf Initial solution speedup:} 1.7
\squishend

\newpage

\section{Manual Parallelization with OpenMP (55 marks)}

This time rather than just apply OpenMP directives to an existing program, you will write the program according to what is written below and verify its correctness with some provided sample files.

The program does a simulation of Coulomb's Law: there are proton and electron particles (that have the standard masses and charges). The protons are kept fixed in place via mechanical forces, but the electrons will move. Electrons move according to classical physics: they are attracted to protons and repelled by other electrons. The program will perform just one step of the simulation.

The program takes parameters:
\begin{enumerate}
\item $h$ -- initial size of simulation step (a measure of time) 
\item $e$ -- epsilon, the amount of error allowed
\item An input file of initial positions (comma separated value file).
\end{enumerate}

The program produces as output the new positions of the electrons and protons (the protons should not move).

The simulation algorithm is:

\begin{enumerate}
\item The initial vector $y_{0}$ contains the positions of the electrons and protons.

\item Calculate the sum of forces $K$ on each electron, and using that, the new positions vector $y_{1}$ as $y_{0} + h \times K$.

\item Calculate a second vector $L$ which is the sum of the forces on each point at $y_{1}$ (but their new positions $y_{2}$ are not needed).

\item For each point, compute $z_{1}$ as $y_{0} + h \times \dfrac{( K + L )}{2}$ (the average of the two forces). 

\item If $|z_{1} - y_{1}| > e$ at any position (e.g., the error at any one position is larger than the tolerance), then the simulation has too much error and we need to go back to step 2, this time with $h$ cut in half.

\end{enumerate}

Once the sequential version is written, you will apply OpenMP directives, one at a time (or in a tightly integrated group) and judge their impact on the runtime of your program as a way to assess what areas benefit most from parallelization and the impact of various OpenMP directives. Note down for your report what is effective and what is ineffective, and what produces invalid results. 

You should also try to achieve the maximum speedup you can while preserving behaviour. 

Submit the final OpenMP-annotated version of your code. Your report will contain the impact of various OpenMP directives, trying some out individually to see which ones are the most important.

\squishlist
  \item {\bf Minimum expected speedup:} n/a
  \item {\bf Initial solution speedup:} n/a
\squishend

\newpage

\section*{Rubric}

The general principle is that correct solutions earn full marks.
However, it is your responsibility to demonstrate to the TA
that your solution is correct. Well-designed, clean solutions 
are therefore more likely to be recognized as correct. 

Solutions that do not compile will earn at most 39\% of the available
marks for that part. Segfaulting or otherwise crashing solutions earn
at most 49\%.

\paragraph{Part 1, Automatic Parallelization (15 marks):}  
\begin{itemize}
\item 10 marks for implementation: A correct solution must:
\begin{itemize}
	\item preserve the behaviour (5 points); and
	\item enable additional parallelization (5 points).
\end{itemize}
 
\item 5 marks for report: include the necessary information
(describing the experiments and results, reasonably speculating about
the cause, and explaining why you preserve behaviour)
\end{itemize}

\paragraph{Part 2, OpenMP Tasks (30 marks):} 

\begin{itemize}
\item 20 marks for implementation: A correct solution must:
\begin{itemize}
	\item properly use OpenMP tasks to get a speedup;
	\item be free of obvious race conditions.
\end{itemize}
\item 10 marks for report: 
\begin{itemize}
\item 7 marks for analyzing the performance
of the provided version, describing the speedup due to your
changes, explaining why your changes improved performance, and
speculating reasonably about further changes. 
\item 3 marks for clarity.
\end{itemize}
\end{itemize}

\paragraph{Part 3, Manual Parallelization (55 marks):} 
\begin{itemize}
\item 20 marks for the single-threaded implementation. 

\item 20 marks for the use of OpenMP pragmas and minor code changes to parallelize the code and get speedup.

\item 15 marks for report: Explain which OpenMP directives helped. Try them out individually and determine the impact of each, and identify which ones work synergistically with others. 3 marks for clarity.
\end{itemize}



\end{document}

